# ============================================================
# CI/CD pipeline for the dns-resolver Rust project
#
# Triggers:
#   - Every push to `main`
#   - Every pull request targeting `main`
#
# Jobs (ordered by fastest-to-slowest to surface failures early):
#   1. fmt          – cargo fmt --check (formatting gate)
#   2. clippy       – cargo clippy -D warnings (lint gate)
#   3. test         – cargo test --all --verbose (unit + integration)
#   4. coverage     – cargo-tarpaulin XML report  [optional, push-only]
#   5. build        – release binary + artifact upload [optional, main push only]
# ============================================================

name: CI

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

# Cancel any in-flight run for the same branch/PR so we don't waste
# runner minutes when a second commit lands before the first job finishes.
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

env:
  # Always emit ANSI colours so log output is readable in GitHub's UI.
  CARGO_TERM_COLOR: always
  # Print a full backtrace on any panic so test failures are easier to debug.
  RUST_BACKTRACE: 1
  # Quieter Cargo output – incremental metadata noise is not useful in CI.
  CARGO_INCREMENTAL: 0

# ============================================================
# Job 1 – Formatting
# Fastest job; run first to give contributors immediate feedback
# on style issues before waiting for clippy or the test suite.
# ============================================================
jobs:
  fmt:
    name: Rustfmt
    runs-on: ubuntu-latest

    steps:
      # ── Checkout ──────────────────────────────────────────
      - name: Checkout source
        uses: actions/checkout@v4

      # ── Toolchain ─────────────────────────────────────────
      # `dtolnay/rust-toolchain` is the canonical, well-maintained action
      # for setting up Rust. We pin to `stable` and add the `rustfmt`
      # component so `cargo fmt` is always available.
      - name: Install stable toolchain (with rustfmt)
        uses: dtolnay/rust-toolchain@stable
        with:
          components: rustfmt

      # ── Check ─────────────────────────────────────────────
      # `--check` exits non-zero if any file would be reformatted,
      # without writing changes. CI fails here on any formatting diff.
      - name: cargo fmt --check
        run: cargo fmt --all -- --check

  # ============================================================
  # Job 2 – Linting (Clippy)
  # Runs concurrently with fmt. Both must pass before `test` starts.
  # ============================================================
  clippy:
    name: Clippy
    runs-on: ubuntu-latest

    steps:
      - name: Checkout source
        uses: actions/checkout@v4

      - name: Install stable toolchain (with clippy)
        uses: dtolnay/rust-toolchain@stable
        with:
          components: clippy

      # ── Dependency cache ──────────────────────────────────
      # `Swatinem/rust-cache` caches ~/.cargo/registry, ~/.cargo/git,
      # and the project's `target/` directory, keyed on Cargo.lock and
      # the host triple. This typically cuts compile times by 60-80 %
      # on subsequent runs.
      - name: Cache Cargo dependencies
        uses: Swatinem/rust-cache@v2
        with:
          # Separate cache bucket per job so clippy's incremental
          # artefacts don't pollute the test build's cache.
          shared-key: clippy

      # ── Lint ──────────────────────────────────────────────
      # `--all-targets` checks lib, bins, tests, benches, and examples.
      # `-D warnings` promotes every Clippy warning to a hard error,
      # ensuring CI fails on any new lint rather than just printing a note.
      - name: cargo clippy -- -D warnings
        run: cargo clippy --all-targets --all-features -- -D warnings

  # ============================================================
  # Job 3 – Test suite
  # Depends on fmt and clippy so that we don't burn runner minutes
  # running tests when there is already a known style/lint failure.
  # ============================================================
  test:
    name: Test Suite
    runs-on: ubuntu-latest
    needs: [fmt, clippy]

    steps:
      - name: Checkout source
        uses: actions/checkout@v4

      - name: Install stable toolchain
        uses: dtolnay/rust-toolchain@stable

      - name: Cache Cargo dependencies
        uses: Swatinem/rust-cache@v2
        with:
          shared-key: test

      # ── Unit tests + inline integration tests ─────────────
      # `--all`    – test every crate in the workspace (future-proof if
      #              the repo grows additional sub-crates).
      # `--verbose` – print each test name and its result; makes it
      #              straightforward to pinpoint which test panicked.
      #
      # This step covers:
      #   • cache.rs        – LRU eviction, TTL expiry, negative cache,
      #                       #[should_panic] heterogeneous RRset guards
      #   • network.rs      – root-server validation, NS/glue extraction,
      #                       pick_ns_server logic
      #   • dns.rs          – packet encode/decode round-trips
      #   • resolver.rs     – mock-backend CNAME chaining, NXDOMAIN,
      #                       SERVFAIL, loop-detection, timeout guard
      #
      # Any panic or assertion failure causes `cargo test` to exit
      # non-zero, which GitHub Actions treats as a job failure.
      - name: Run unit and integration tests
        run: cargo test --all --verbose

      # ── Live network / recursive-resolution tests ──────────
      # Tests marked `#[ignore]` require real network access (root-server
      # queries, iterative resolution, TCP fallback). They are excluded
      # from the default run above and executed here with `--ignored`.
      #
      # `continue-on-error: true` prevents transient DNS timeouts in the
      # CI network environment from blocking the entire pipeline, while
      # still surfacing the result in the job summary for visibility.
      - name: Run ignored (live network) tests
        run: cargo test --all --verbose -- --ignored
        continue-on-error: true

      # ── Malformed-packet fuzz inputs ──────────────────────
      # Run any test whose name contains "malform" or "decode" explicitly
      # to make the intent clear in the job log. These are already
      # included in the `cargo test --all` step; this step just adds
      # a named log group for auditing purposes.
      - name: Confirm malformed-packet decode tests ran
        run: |
          echo "Verifying decode/malformed tests are present:"
          cargo test --all --verbose 2>&1 | grep -E "(malform|decode|truncat|overflow|invalid)" || true

  # ============================================================
  # Job 4 – Code Coverage  (optional, push-only)
  # Only runs on pushes to main to avoid burning runner minutes on
  # every draft PR. Results are uploaded as a workflow artefact and
  # can be forwarded to Codecov / Coveralls by adding an extra step.
  # ============================================================
  coverage:
    name: Code Coverage
    runs-on: ubuntu-latest
    # Coverage is informational; a drop in coverage should not block
    # merging. Remove the `continue-on-error` line if you want it to.
    continue-on-error: true
    # Only run on direct pushes to main (skip for PRs).
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    needs: [test]

    steps:
      - name: Checkout source
        uses: actions/checkout@v4

      - name: Install stable toolchain
        uses: dtolnay/rust-toolchain@stable

      - name: Cache Cargo dependencies
        uses: Swatinem/rust-cache@v2
        with:
          shared-key: coverage

      # ── Install cargo-tarpaulin ───────────────────────────
      # Tarpaulin instruments the binary for line coverage.
      # `--locked` keeps the install reproducible across runs.
      # We cache the tarpaulin binary itself via the cargo registry
      # cache populated by Swatinem/rust-cache above.
      - name: Install cargo-tarpaulin
        run: cargo install cargo-tarpaulin --locked

      # ── Generate coverage report ──────────────────────────
      # `--all`          – measure every crate in the workspace.
      # `--out Xml`      – emit Cobertura XML (compatible with most
      #                   coverage dashboards).
      # `--output-dir`   – keep artefacts in a predictable location.
      # `--timeout 300`  – some TTL-expiry tests sleep up to 61 s;
      #                   give tarpaulin enough headroom.
      # `--avoid-cfg-tarpaulin` – prevent dead-code from inflating
      #                   the coverage denominator.
      - name: Generate coverage (cargo-tarpaulin)
        run: |
          mkdir -p coverage
          cargo tarpaulin \
            --all \
            --out Xml \
            --output-dir coverage \
            --timeout 300 \
            --avoid-cfg-tarpaulin \
            --verbose

      # ── Upload report as an artefact ─────────────────────
      # The XML report is retained for 7 days and can be downloaded
      # from the Actions run summary page.
      - name: Upload coverage report
        uses: actions/upload-artifact@v4
        with:
          name: coverage-report-${{ github.sha }}
          path: coverage/
          retention-days: 7

  # ============================================================
  # Job 5 – Release build + binary upload  (optional, push-only)
  # Compiles an optimised release binary and uploads it as a
  # workflow artefact so it can be downloaded and smoke-tested
  # without running the full dev toolchain locally.
  # ============================================================
  build:
    name: Release Build
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    needs: [test]

    steps:
      - name: Checkout source
        uses: actions/checkout@v4

      - name: Install stable toolchain
        uses: dtolnay/rust-toolchain@stable

      - name: Cache Cargo dependencies
        uses: Swatinem/rust-cache@v2
        with:
          shared-key: release

      # ── Compile release binary ────────────────────────────
      # `--release` enables full optimisations (opt-level = 3),
      # LTO, and dead-code elimination. The resulting binary is
      # placed at `target/release/dns-resolver`.
      - name: Build release binary
        run: cargo build --release --verbose

      # ── Verify the binary exists and is executable ────────
      - name: Smoke-check binary
        run: |
          ls -lh target/release/dns-resolver
          file target/release/dns-resolver

      # ── Upload binary as a workflow artefact ──────────────
      # Artefacts are retained for 30 days and accessible from
      # the Actions run summary. Useful for quick manual testing
      # without a local Rust installation.
      - name: Upload release binary
        uses: actions/upload-artifact@v4
        with:
          name: dns-resolver-linux-x86_64-${{ github.sha }}
          path: target/release/dns-resolver
          retention-days: 30
